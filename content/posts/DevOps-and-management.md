---
title: "DevOps and Management"
date: 2018-03-25T12:29:54-05:00
draft: true
---

I recently gave a talk at [NEW CodeCamp](http://newcodecamp.com) on a topic that over the last several months has become something I enjoy talking about and working with - Octopus Deploy. After the session, I was talking with someone who attended about their own deployment process. I've thought about our conversation, and I've decided to write my thoughts on the situation.

Unfortunately, his story is likely not all that unusual. In short, their update process consists mostly of dropping only the assemblies or files that were modified into their production environment, rather than the full software package. In the case of websites, it would be HTML or ASPX files, and in the case of a windows application it would be the supporting binary DLLs (the primary executable would rarely change, understandably).

From the perspective of the company management, this can be a very attractive method of doing things: if you have multiple bug fixes in the works, it's easy to deploy the fix in any order once it has been tested (assuming they change different files), and the process appears to be relatively low-risk. It also allows their testing pipeline to be filled relatively efficiently while giving the impression of a real CI/CD pipeline to production.

One idea that we came up with to address this situation was to package each individual file as its own package, and then deploy only those files that change. On the surface, this seems like a reasonable solution - in fact, in many ways as developers we do this as part of normal development. Think of what is actually happening when you update NuGet/NPM packages, Ruby Gems, etc. The difference is that these dependencies are wrapped into and bundled with your application and deployed at the same time as you generally deploy a new version of your application, not independently upgraded. And there tends to be a very good reason for that.

The biggest risk I see is compatibility. While testing the application itself would generally uncover changes that would result in compile-time errors (for example, making a breaking change to a method signature), it may not uncover more subtle issues.

I always seem to come back to the concept of emergent bugs - bugs that occur because of two independent changes that, on their own, operate correctly but when combined produce unexpected results. These changes can sometimes be found through various automated testing techniques, but other times it takes end-to-end testing. If you treat each change only in isolation, there is no way of identifying these kinds of interactions until it goes to production. And once there, it can be more difficult to track down the issue, since you need to determine the state of each individual component to determine when the bug arises.

Then there's also the practicality of maintaining such a system. Within the context of Octopus (and other systems that operate similarly), you would have to specifically require each package that would need to be deployed; the process to deploy your product would be a massive number of steps (at least one for each file), and every package would have their own distinct version number, causing a headache trying to figure out just what version of which file should go at any given time. This isn't even touching on the maintenance when new files inevitably need to be added to the application.

Finally, I have to take a step back and really ask about the elephant in the room: Why? Really, doing this type of system doesn't actually give any additional flexibility or benefit over traditional Continuous Deployment type systems. In fact, in some circumstances it actually gives you _less_ flexibility. One perspective I always tend to have when it comes to deploying software is on the ability to scale out. In this type of scenario if you wanted to deploy your software to a new location, or if you are already deploying to multiple locations, you have to do a significant amount more work. You now have to remember to update these files in multiple locations, or in the case of a new deployment you have to deploy your "base" image (which is quite possibly a few months old), then figure out which files need to be changed from there. In either case, you now have a considerable potential for having mismatched versions in your own production environment, which can make debugging new issues even more difficult.

If there's one thing I've learned while thinking about this situation and the possible solutions, it's that CI/CD best practices are best practices for reason. When management doesn't fully understand the _why_ of a process, it can be difficult to move to a better place. But the nice thing about the current state of technology is that doing a proper deployment pipeline doesn't mean you have to sacrifice your agility of getting features and bug fixes out the door; in fact, in many ways it helps to be more agile.

One thing I keep coming back to is something I learned early in my career. We would have auditors come in on a yearly basis and examine the IT department, software engineering included, to help identify potential risks and concerns. During this audit, they would look at things like who had access to mission-critical servers, examine how access to those servers was regulated, and even checked that the various procedures were being followed.

When it came to software development, they pulled a random sample of code changes (normally driven by commit messages in source control), and looked at a couple things around each one - namely, why the change was made, documentation around testing/sign off of the change and _proof that the code that was tested and approved was the same code that ended up in the production environment_.

That last point has always stuck with me, and I think that when it comes to things like CI/CD, it's something that should always be baked into the system - even if you aren't being audited on a regular basis. As software becomes more pronounced to our every day lives, being able to tie a specific change to a given version (and vice versa) becomes important as well, whether you're writing the next generation of AI software for self-driving cars or a game for people to enjoy on the bus on their way to work.
